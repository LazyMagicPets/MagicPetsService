AWSTemplateFormatVersion: '2010-09-09'

Description: | 
  This stack creates ubiqutious cloudfront policies, functions etc. for tenancies
Parameters:
  SystemKey:
    Description: "System Name"
    Type: String
  EnvironmentParameter:
    Description: "Environment"
    Type: String
    Default: "dev"
    AllowedValues:
      - dev
      - test
      - prod
  KeyValueStoreArnParameter:
    Description: "The CloudFront KeyValueStore ARN"
    Type: String    

Conditions:
  IsDev: !Equals [!Ref EnvironmentParameter, "dev"]

Resources:
  # The Request function is used to update S3 origins on the fly using
  # an associated CloudFront KeyValueStore. This function reads kvs  
  # using the [subdomain.]domain as the key. The value returned 
  # is a configuration object optimized for size because KVS 
  # values must be under 1KB in size and we don't want more than 
  # one kvs access per request.
  # Each kvs JSON entry has the following form:
  # { 
  #     env: "",
  #     tenantKey: "",
  #     subtenantKey: "",
  #     systemKey: "",
  #     ss: "", // system sufix
  #     ts: "", // tenant sufix
  #     sts: "", // subtenant sufix
  #     region: "",
  # }
  # Each Behavior entry is an array of strings. See the AssetType switch 
  # statement in the function for documentatio of each type of behavior entry.
  # 
  Request:  
    Type: AWS::CloudFront::Function
    Properties:
      Name: !Sub ${SystemKey}---request
      AutoPublish: true
      FunctionConfig:
        Comment: 'Handle Asset Requests.'
        Runtime: cloudfront-js-2.0
        KeyValueStoreAssociations:
          - KeyValueStoreARN: !Ref KeyValueStoreArnParameter
      FunctionCode: |
        import cf from 'cloudfront';
        const kvs = cf.kvs(); 
        async function handler(event) {
            const request = event.request;
            const headers = request.headers;
            const uri = request.uri;  
            const origin = headers.origin && headers.origin.value;
            const host = request.headers.host.value;
            const debug = false;
            if(debug) console.log("host: " + host);
    

            // Grab the Config for the domain
            var config = null;
            const kvsKey = host;  
            try {
                config = await kvs.get(kvsKey);
            } catch (err) {
                console.log("KVS " + kvsKey+ " entry not found.");
            }
            if(!config)
                return {
                    statusCode: 404,
                    statusDescription: 'Not Found',
                    body: 'Missing Config'
                };      
            if(debug) console.log("config:" + config);
            config = JSON.parse(config);
            if(!config || !config.behaviors)
                return {
                    statusCode: 404,
                    statusDescription: 'Not Found',
                    body: 'Bad Config'
                };   

            // Handle preflight requests from localhost in dev environment
            if (
                config.env === 'dev'
                && request.method === 'OPTIONS' 
                && origin 
                && (origin.startsWith('https://localhost:') || origin.startsWith('http://localhost:')) 
                && headers['access-control-request-method']
            ) {
                // Return a 204 No Content for preflight
                return {
                    statusCode: 204,
                    statusDescription: 'No Content',
                    headers: {
                        'access-control-allow-origin': { value: origin },
                        'access-control-allow-methods': { value: 'GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH' },
                        'access-control-allow-headers': { value: 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token' },
                        'access-control-max-age': { value: '86400' },
                        'cache-control': { value: 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' }
                    }
                };
            }

            const tenantKey = config.tenantKey;
            const subtenantKey = config.subtenantKey;
            const systemKey = config.systemKey;
            const ss = config.ss;
            const ts = config.ts;
            const sts = config.sts;

            var behavior = null;
            var found = false;
            var b = 0;
            if(config.behaviors) {
                if(debug) console.log("Matching uri: " + uri);

                const behaviorsRef = new Array(100);
                for (let i = 0; i < config.behaviors.length; i++) {
                    const value = config.behaviors[i]; 
                    // behaviors are an array begining with [path, ..]
                    // prefix is a comma separated string where each of the elements
                    // can be a valid prefix match. A prefix is just the beginning 
                    // of the path that we want to match on.
                    var prefixes = value[0].split(',');
                    for(let p = 0; p < prefixes.length; p++) {
                        behaviorsRef[b++] = [prefixes[p], i];
                    }
                }
        
                // Sort the behaviors descending by the path length
                behaviorsRef.sort(function(a, b) {
                    return b[0].length - a[0].length;
                });
        
                if(debug) {
                    for(let br = 0; br < b; br++) {
                        const item = config.behaviors[behaviorsRef[br][1]];
                        console.log('[' + br + '] ' + behaviorsRef[br][0] + " -> " + item.slice(1).join(", "));
                    }
                }

                for(let br = 0; br < b; br++) {
                    const behaviorRef = behaviorsRef[br];

                    if (uri.startsWith(behaviorRef[0])) {
                        behavior = config.behaviors[behaviorRef[1]]
                        if(debug) console.log("found:" + br);
                        found = true;
                        break;                
                    }            
                }
            }   

            if(!found) {
               return {
                    statusCode: 404,
                    statusDescription: 'Not Found',
                    body: 'No path match'
                };         
            }

            const assetType = behavior[1];
            const awssuffix = '.awsamazon.com';
            var originPath = "";
            var removePrefix = false;
            var addCacheHeader = false;
            var assetName = "";
            var behaviorLevel = 0;
            var assetTenantKey = "";
            var assetSubtenantKey = "";
            switch(assetType) {
                case "api":
                    // behavior array
                    //   0 path: 
                    //   1 assetType:
                    //   2 apiName: 
                    //   3 region:
                    //   4 level:
                    // maps into
                    // [apiName].execute-api.[region].amazonaws.com
                    assetName = behavior[2] + '.execute-api.' + behavior[3] + awssuffix;
                    originPath = config.env; // used to set stage name
                    break;
                case "assets":
                    // behavior array
                    //   0 path:
                    //   1 assetType:
                    //   2 guid:
                    //   3 region:
                    //   4 level:
                    // maps into
                    // [systemKey]-[tenantKey]-[subtenantKey]-[assetType]-[guid].s3.[region].amazonaws.com
                    behaviorLevel = behavior[4]
                    assetTenantKey = behaviorLevel > 0 ? config.tenantKey : ''
                    assetSubtenantKey = behaviorLevel > 1 ? config.subtenantKey : ''
                    assetName = config.systemKey + '-' + assetTenantKey + '-' + assetSubtenantKey + '-' + assetType + '-' + behavior[2] + '.s3.' + behavior[3] + awssuffix;
                    removePrefix = true;
                    addCacheHeader = true;
                    break;
                case "webapp":
                    // behavior array
                    //   0 path:
                    //   1 assetType:
                    //   2 appName:
                    //   3 guid:
                    //   4 region:
                    //   5 level:
                    // maps into
                    // [systemKey]-[tenantKey]-[subtenantKey]-[assetType]-[appName]-[guid].s3.[region].amazonaws.com            
                    behaviorLevel = behavior[4]
                    assetTenantKey = behaviorLevel > 0 ? config.tenantKey : ''
                    assetSubtenantKey = behaviorLevel > 1 ? config.subtenantKey : ''
                    assetName = config.systemKey + '-' + assetTenantKey + '-' + assetSubtenantKey + '-' + assetType + '-' + behavior[2] + '-' + behavior[3] + '.s3.' + behavior[4] + awssuffix;
                    removePrefix = true;
                    addCacheHeader = true;
                    originPath = "/wwwroot"
                    break;
            }

            // perform any replacements in assetName
            assetName = assetName.replaceAll('{sts', sts);
            assetName = assetName.replaceAll('{ts}', ts);
            assetName = assetName.replaceAll('{ss}', ss);

            // Check for any remaining unreplaced placeholders
            if (assetName.includes('{')) {
                return {
                    statusCode: 404,
                    statusDescription: 'Not Found',
                    body: 'Bad Config behavior entry. Missing replacement value'
                };
            }

            cf.updateRequestOrigin({
              "domainName": assetName,
              "originPath": originPath
            });

            if(debug) console.log("originDomainName: " + assetName + ", originPath: " + originPath);

            // Webapp page navigation intercept
            if(assetType == 'webapp' && uri.endsWith("Page")) {
                try {
                    const url = new URL(uri);
                    const pathSegments = url.pathname.split('/');
                    pathSegments.pop(); // Remove last segment
                    url.pathname = pathSegments.join('/');
                    uri = url.toString();
                } catch (e) {
                    uri = uri.substring(0, uri.lastIndexOf('/'));
                }             
            }

            // Remove the prefix form the path. examples
            // /tenancy/something -> /something
            // /system/something -> /something
            // /store/index.html -> /index.html
            if(removePrefix) {
                var secondSlash = uri.indexOf('/', 1); 
                request.uri = secondSlash > 0 ? uri.slice(secondSlash) : '/';
            }
            if(debug) console.log("uri: " + request.uri);
            if(addCacheHeader) {
                headers['x-custom-cache-key'] = { value: assetName + '-' + request.uri }; // We use a header to do caching of assets    
            }
            return request;
        }



  CacheByHeaderDevPolicy:
    Type: 'AWS::CloudFront::CachePolicy'
    Properties:
      CachePolicyConfig:
        Name: !Sub ${SystemKey}-CacheByHeaderDevPolicy
        Comment: 'Cache policy using custom x-custom-cache-key header'
        DefaultTTL: 1  # use minimum TTL in development
        MaxTTL: 31536000   # 1 year in seconds
        MinTTL: 1
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: none
          EnableAcceptEncodingGzip: true
          EnableAcceptEncodingBrotli: true
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers: 
              - 'x-custom-cache-key'
          QueryStringsConfig:
            QueryStringBehavior: none

  CacheByHeaderProdPolicy:
    Type: 'AWS::CloudFront::CachePolicy'
    Properties:
      CachePolicyConfig:
        Name: !Sub ${SystemKey}-CacheByHeaderProdPolicy
        Comment: 'Cache policy using custom x-custom-cache-key header'
        DefaultTTL: 86400  # 1 day in seconds
        MaxTTL: 31536000   # 1 year in seconds
        MinTTL: 1
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: none
          EnableAcceptEncodingGzip: true
          EnableAcceptEncodingBrotli: true
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers: 
              - 'x-custom-cache-key'
          QueryStringsConfig:
            QueryStringBehavior: none

  CachingOptimizedDevPolicy:
    Type: 'AWS::CloudFront::CachePolicy'
    Properties:
      CachePolicyConfig:
        Name: !Sub ${SystemKey}-CachingOptimizedDev
        Comment: 'Managed policy for optimized caching for dev environment'
        DefaultTTL: 1  # allows rapid update for development testing
        MaxTTL: 31536000   # 1 year in seconds
        MinTTL: 1
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: none
          EnableAcceptEncodingGzip: true
          EnableAcceptEncodingBrotli: true
          HeadersConfig:
            HeaderBehavior: none
          QueryStringsConfig:
            QueryStringBehavior: none


# CloudFront Policies 
# There are three types of CloudFront policies:
# - CachePolicy: Determines the cache key and the TTLs for the cacheable content.
# - OriginRequestPolicy: Determines the headers, query strings, and cookies that are included in requests that CloudFront sends to the origin.
#       Note that any headers included in the CachePolicy are also passed through to the origin.  
# - ResponseHeadersPolicy: Determines the headers that CloudFront includes in the response that it returns to the viewer.
#       Note: The ResponseHeadersPolicy may contain distribution specific content in the CSP, so it is defined in the sam.cloudfront.yaml template.
# AWS Provides some managed policies that can be used in lieu of creating custom policies. The IDs for these policies don't change and 
# are provided below.
#
# Type: AWS::CloudFront::CachePolicy
# - 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # Managed-CachingDisabled, recommended for API Gateway
# - 658327ea-f89d-4fab-a63d-7e88639e58f6 # Managed-CachingOptimized
# - b2884449-e4de-46a7-ac36-70bc7f1ddd6d # Managed-CachingOptimizedForUncompressedObjects
# - 08627262-05a9-4f76-9ded-b50ca2e3a84f # Managed-Elemental-MediaPackage

# Type: AWS::CloudFront::OriginRequestPolicy
# - 216adef6-5c7f-47e4-b989-5492eafa07d3 # Managed-AllViewer
# - 33f36d7e-f396-46d9-90e0-52428a34d9dc # Managed-AllViewerAndCloudFrontHeaders-2022-06
# - b689b0a8-53d0-40ab-baf2-68738e2966ac # Managed-AllViewerExceptHostHeader, recommended for API Gateway
# - 59781a5b-3903-41f3-afcb-af62929ccde1 # Managed-CORS-CustomOrigin
# - 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # Managed-CORS-S3Origin
# - 775133bc-15f2-49f9-abea-afb2e0bf67d2 # Managed-Elemental-MediaTailor-PersonalizedManifests
# - acba4595-bd28-49b8-b9fe-13317c0390fa # Managed-UserAgentRefererHeaders

  # DevCachePolicy:
  #   Type: AWS::CloudFront::CachePolicy
  #   Properties:
  #     CachePolicyConfig:
  #       Name: !Sub ${AWS::StackName}-DevCachePlcy-${GuidParameter}
  #       DefaultTTL: 1
  #       MaxTTL: 1
  #       MinTTL: 1
  #       ParametersInCacheKeyAndForwardedToOrigin: 
  #         CookiesConfig:
  #           CookieBehavior:  all
  #         QueryStringsConfig:
  #           QueryStringBehavior: all
  #         EnableAcceptEncodingBrotli: true
  #         EnableAcceptEncodingGzip: true
  #         HeadersConfig: 
  #           HeaderBehavior: whitelist 
  #           Headers:
  #           - Authorization 
  #           - Accept-Charset 
  #           - Origin
  #           - Access-Control-Request-Method 
  #           - Access-Control-Request-Headers 
  #           - Accept 
  #           - Referer 
  #           - Accept-Language 
  #           - Accept-Datetime

  WebSocketOriginRequestPolicy:
    Type: AWS::CloudFront::OriginRequestPolicy
    Properties:
      OriginRequestPolicyConfig:
        Name: !Sub ${SystemKey}-WSOrignReqPlcy
        Comment: "OriginRequestPolciy - Forward necessary headers for WebSocket connections"
        HeadersConfig:
          HeaderBehavior: whitelist
          Headers:
            - Sec-WebSocket-Key
            - Sec-WebSocket-Version
            - Sec-WebSocket-Protocol
            - Sec-WebSocket-Extensions
            - Sec-WebSocket-Accept
            - Host
            - Origin
        CookiesConfig:
          CookieBehavior: none
        QueryStringsConfig:
          QueryStringBehavior: all


Outputs:
  CachePolicyId:
    # Managed-CachingOptimized
    Value: !If [IsDev, !Ref CachingOptimizedDevPolicy, 658327ea-f89d-4fab-a63d-7e88639e58f6]

  CacheByHeaderPolicyId:
    Value: !If [IsDev, !Ref CacheByHeaderDevPolicy, !Ref CacheByHeaderProdPolicy]

  OriginRequestPolicyId:
    # Managed-AllViewerExceptHostHeader
    Value: b689b0a8-53d0-40ab-baf2-68738e2966ac 

  ApiOriginRequestPolicyId:
    # Managed-AllViewerExceptHostHeader
    Value: b689b0a8-53d0-40ab-baf2-68738e2966ac 

  ApiCachePolicyId:
    # Managed-CachingDisabled
    Value: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad 

  WebsocketOriginRequestPolicyId:
    Value: !Ref WebSocketOriginRequestPolicy

  RequestFunctionArn:
    Value: !GetAtt Request.FunctionARN
  
  ApiRequestFunctionArn:
    Value: !GetAtt Request.FunctionARN

